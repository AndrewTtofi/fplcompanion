name: Deploy to Production

on:
  workflow_call:
    inputs:
      deploy_ref:
        description: 'Git ref to deploy (tag)'
        required: true
        type: string
  workflow_dispatch:
    inputs:
      ref:
        description: 'Git ref to deploy (tag, branch, or SHA)'
        required: false
        default: ''

env:
  APP_DIR: /opt/fplcompanion
  DOMAIN: fplcompanion.com

jobs:
  # -------------------------------------------------------------------
  # 1. Run the full CI checks before deploying
  # -------------------------------------------------------------------
  ci:
    name: Pre-deploy CI
    runs-on: ubuntu-latest

    steps:
      - name: Determine ref
        id: resolve
        run: |
          REF="${{ inputs.deploy_ref || inputs.ref || github.sha }}"
          echo "ref=$REF" >> $GITHUB_OUTPUT

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.resolve.outputs.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install and lint backend
        working-directory: ./backend
        run: |
          npm install --prefer-offline
          npm run lint || echo "No lint script configured"

      - name: Install, lint, and build frontend
        working-directory: ./frontend
        run: |
          npm install --prefer-offline
          npm run lint || echo "No lint script configured"
          npm run build

      - name: Test Docker builds
        run: |
          docker build -f ./backend/Dockerfile.prod ./backend -t fpl-backend:ci-test
          docker build -f ./frontend/Dockerfile.prod ./frontend -t fpl-frontend:ci-test

  # -------------------------------------------------------------------
  # 2. Deploy to Lightsail via SSH
  # -------------------------------------------------------------------
  deploy:
    name: Deploy to Lightsail
    runs-on: ubuntu-latest
    needs: ci
    environment: production
    concurrency:
      group: production-deploy
      cancel-in-progress: false

    steps:
      - name: Determine deploy ref
        id: ref
        run: |
          REF="${{ inputs.deploy_ref || inputs.ref || github.sha }}"
          echo "deploy_ref=$REF" >> $GITHUB_OUTPUT
          echo "Deploying ref: $REF"

      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1
        with:
          host: ${{ secrets.LIGHTSAIL_HOST }}
          username: ${{ secrets.LIGHTSAIL_USER }}
          key: ${{ secrets.LIGHTSAIL_SSH_KEY }}
          command_timeout: 10m
          script: |
            set -euo pipefail
            APP_DIR="${{ env.APP_DIR }}"
            DEPLOY_REF="${{ steps.ref.outputs.deploy_ref }}"

            echo "=== Deploying $DEPLOY_REF to production ==="

            # Clone on first deploy, fetch on subsequent deploys
            if [ ! -d "$APP_DIR/.git" ]; then
              echo "[1/5] Cloning repository..."
              git clone https://github.com/${{ github.repository }}.git "$APP_DIR"
              cd "$APP_DIR"
            else
              echo "[1/5] Fetching latest changes..."
              cd "$APP_DIR"
              git fetch --all --tags --prune
            fi

            # Checkout the target ref
            echo "[2/5] Checking out $DEPLOY_REF..."
            git checkout "$DEPLOY_REF"

            # Write environment file for docker-compose
            echo "[3/5] Writing environment config..."
            cat > "$APP_DIR/.env" << EOF
            GOOGLE_AI_API_KEY=${{ secrets.GOOGLE_AI_API_KEY }}
            EOF

            # Ensure SSL cert exists so nginx can start
            echo "[4/7] Ensuring SSL certificates..."
            cd "$APP_DIR"
            docker compose -f docker-compose.prod.yml run --rm --entrypoint "" certbot sh -c "
              if [ ! -f /etc/letsencrypt/live/fplcompanion.com/fullchain.pem ]; then
                echo 'No SSL cert found. Creating self-signed placeholder...'
                mkdir -p /etc/letsencrypt/live/fplcompanion.com
                openssl req -x509 -nodes -newkey rsa:2048 -days 1 \
                  -keyout /etc/letsencrypt/live/fplcompanion.com/privkey.pem \
                  -out /etc/letsencrypt/live/fplcompanion.com/fullchain.pem \
                  -subj '/CN=fplcompanion.com' 2>/dev/null
                touch /etc/letsencrypt/live/fplcompanion.com/.placeholder
              else
                echo 'SSL certificate exists.'
              fi
            "

            # Build and deploy containers
            echo "[5/7] Building and starting containers..."

            # Build new images
            docker compose -f docker-compose.prod.yml build --no-cache

            # Restart services (redis stays up to preserve cache)
            docker compose -f docker-compose.prod.yml up -d --force-recreate --remove-orphans

            # Clean up old images to save disk space
            docker image prune -f

            # If using a placeholder cert, attempt to get a real one now that nginx is up
            echo "[6/7] Checking SSL certificate..."
            IS_PLACEHOLDER=$(docker compose -f docker-compose.prod.yml run --rm --entrypoint "" certbot sh -c \
              "test -f /etc/letsencrypt/live/fplcompanion.com/.placeholder && echo yes || echo no")
            if [ "$IS_PLACEHOLDER" = "yes" ]; then
              echo "Attempting to obtain real SSL certificate..."
              docker compose -f docker-compose.prod.yml run --rm --entrypoint "" certbot \
                certbot certonly --webroot -w /var/www/certbot \
                --cert-name fplcompanion.com \
                -d fplcompanion.com -d www.fplcompanion.com \
                --non-interactive --agree-tos --email admin@fplcompanion.com --no-eff-email \
                && {
                  echo "Real SSL certificate obtained. Reloading nginx..."
                  docker compose -f docker-compose.prod.yml exec -T nginx nginx -s reload
                  # Remove placeholder marker
                  docker compose -f docker-compose.prod.yml run --rm --entrypoint "" certbot \
                    rm -f /etc/letsencrypt/live/fplcompanion.com/.placeholder
                } || echo "Certbot failed (DNS may not be ready). Using self-signed placeholder."
            else
              echo "Valid SSL certificate already in place."
            fi

            # Wait for services to be healthy
            echo "[7/7] Verifying deployment..."
            sleep 10

            # Check backend health (node is available in the container, wget/curl are not)
            for i in $(seq 1 12); do
              if docker compose -f docker-compose.prod.yml exec -T backend node -e "require('http').get('http://localhost:3001/health', r => process.exit(r.statusCode === 200 ? 0 : 1)).on('error', () => process.exit(1))" 2>/dev/null; then
                echo "Backend is healthy."
                break
              fi
              if [ "$i" -eq 12 ]; then
                echo "ERROR: Backend health check failed after 60s"
                docker compose -f docker-compose.prod.yml logs --tail=50 backend
                exit 1
              fi
              echo "Waiting for backend to be healthy... ($i/12)"
              sleep 5
            done

            # Check frontend health
            for i in $(seq 1 12); do
              if docker compose -f docker-compose.prod.yml exec -T frontend node -e "require('http').get('http://localhost:3000', r => process.exit(r.statusCode === 200 ? 0 : 1)).on('error', () => process.exit(1))" 2>/dev/null; then
                echo "Frontend is healthy."
                break
              fi
              if [ "$i" -eq 12 ]; then
                echo "ERROR: Frontend health check failed after 60s"
                docker compose -f docker-compose.prod.yml logs --tail=50 frontend
                exit 1
              fi
              echo "Waiting for frontend to be healthy... ($i/12)"
              sleep 5
            done

            # Check nginx (curl is available on the host)
            for i in $(seq 1 6); do
              if curl -s -o /dev/null -w "" http://localhost:80 2>/dev/null; then
                echo "Nginx is responding."
                break
              fi
              if [ "$i" -eq 6 ]; then
                echo "WARNING: Nginx check inconclusive (may need SSL cert setup)"
              fi
              sleep 5
            done

            echo ""
            echo "=== Deployment complete ==="
            echo "Version: $DEPLOY_REF"
            echo "URL: https://fplcompanion.com"
            docker compose -f docker-compose.prod.yml ps

      - name: Deployment summary
        run: |
          echo "### Deployment Successful" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Version:** ${{ steps.ref.outputs.deploy_ref }}" >> $GITHUB_STEP_SUMMARY
          echo "**URL:** https://${{ env.DOMAIN }}" >> $GITHUB_STEP_SUMMARY
          echo "**Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY

  # -------------------------------------------------------------------
  # 3. Post-deploy smoke test from outside the server
  # -------------------------------------------------------------------
  smoke-test:
    name: Smoke Test
    runs-on: ubuntu-latest
    needs: deploy

    steps:
      - name: Wait for deployment to stabilize
        run: sleep 15

      - name: Test HTTPS endpoint
        run: |
          # -k allows self-signed certs (first deploy uses a placeholder cert)
          HTTP_STATUS=$(curl -sk -o /dev/null -w "%{http_code}" https://${{ env.DOMAIN }} --max-time 30)
          echo "HTTPS status: $HTTP_STATUS"
          if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 400 ]; then
            echo "HTTPS endpoint is live."
          else
            echo "ERROR: Site returned HTTP $HTTP_STATUS"
            exit 1
          fi

      - name: Test API health
        run: |
          HTTP_STATUS=$(curl -sk -o /dev/null -w "%{http_code}" https://${{ env.DOMAIN }}/health --max-time 15)
          echo "Health endpoint status: $HTTP_STATUS"
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "API health check passed."
          else
            echo "ERROR: Health check returned $HTTP_STATUS"
            exit 1
          fi

      - name: Test API data endpoint
        run: |
          HTTP_STATUS=$(curl -sk -o /dev/null -w "%{http_code}" https://${{ env.DOMAIN }}/api/gameweek/current --max-time 15)
          echo "API /gameweek/current status: $HTTP_STATUS"
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "API data endpoint is working."
          else
            echo "WARNING: API endpoint returned $HTTP_STATUS (may be expected if FPL season is inactive)"
          fi

      - name: Smoke test summary
        run: |
          echo "### Smoke Tests Passed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "All production endpoints verified." >> $GITHUB_STEP_SUMMARY
